
//x = elemento da inserire dentro l'array ordinato
//A array


BinaryInsertionSort(*A)                                      T(n) = n + 4(n-1) + (n-1)* log2(n) = 5n - 4 + nlog2(n) - log2(n)
    for i = 1 to length(A) do                                n  
        position = BinarySearchPosition(A, A[x])             n-1 * T(BinarySearchPosition)
        
        tmp  = A[x]                                          n-1  

        memcpy( &A[position+1], &A[position], i-positition)  2(n-1)
        
        A[position] = tmp                                    n-1
    end for
return 



BinarySearchPosition(*A, x, i, j)                            T(n) = log2(n)                              
    m = (i+j)/2                                            
    
    if A[m] = x                                            
        return m                                           
    else if A[m] > x                                        
        return BinarySearchPosition(A, x, m+1, j)
    else
        return BinarySearchPosition(A, x, i, m-1)


_________________________


MergeSort(A , i, j)  //pre i=0 e j= len(a)
    if (j-i) < K then
        BinaryInsertionSort(A, i, j)
    else    
        m = (j-i)/2
        MergeSort(A, i, m-1) //controllare perchè critico
        MergeSort(A, m, j)
        Merge(A, i,m,j)
return

Merge(A, i, m, j)
    arrSupporto = new Array(j-i)

    A1 = new array(m-i)
    A2 = new array(j-m)

    memcpy(A1, &A[i], m-i-1) //controllare perchè critico
    memcpy(A2, &A[m], j-m)

    a = 0 //posizione su A1
    b = 0 //posizione su A2
    c = 0 //posizione su arrSupporto

    for c=0 to j-i do   
        if a<(m-i) AND A1[a] <= A2[b] then  
            arrSupporto[c] = A1[a]
            a++
        else 
            arrSupporto[c] = A2[b]
            b++
        end if
    end for

    memcpy(&A[i], &A1, m-i-1)
    memcpy(&A[m], &A2, j-m)

return 



    
    
    







 